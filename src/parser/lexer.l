%{
#include "lexer.hpp"  // Generated by bison
#include "location.hh"
#include <string>
#define yyterminate() yy::parser::make_END(loc);
%}

%option noyywrap
%option nodefault
%option yyclass="Scanner"
%option c++

%{
    // Initialize location at the start of each scan
    #define YY_USER_ACTION \
            loc.step();\
            loc.columns(yyleng); \

%}

%%
"#"        { 
              char c;
              while ((c = yyinput()) != 0 && c != '\n') {
                loc.columns(1);  // Track each character
              }
              if (c == '\n') {
                unput(c);  // Put newline back for proper tracking
              }
            }
[ \t]      {  }  // Track whitespace (but not newlines)
\n          { loc.lines(); }  // Track newlines
['`]           { return yy::parser::make_QUOTE(loc); }
"("           { return yy::parser::make_LPAREN(loc); }
")"           { return yy::parser::make_RPAREN(loc); }
"true"        { return yy::parser::make_TRUE(loc); }
"false"       { return yy::parser::make_FALSE(loc); }
-?[0-9]+        { return yy::parser::make_INTEGER(atoi(yytext), loc); }
-?[0-9]+\.[0-9]+ { return yy::parser::make_REAL(atof(yytext), loc); }
[a-zA-Z][a-zA-Z0-9]* { return yy::parser::make_IDENTIFIER(make_nn_shared<Identifier>(loc, std::string{yytext}), loc); }
.           { 
                // Create error token containing the invalid character
                std::string error_char(1, *yytext);
                return yy::parser::make_ERROR(error_char, loc); 
            }
<<EOF>>     { return yyterminate(); }

%%

